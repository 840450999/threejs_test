const { initEvent, extendEvent } = require('./util/event');
const { isArr } = require('./util/type')

// fns 变数
// fns 衍 t_function：执行方法 | v_scope：变数区域  ==> 递进  
// v_scope 衍 t_string:消息区域 | t_number:方法特性 


// v_scope 分象+拓展
function s_or_n(arr) {
    var l = arr.length,
        s = [], n = [],
        offset = 0;
    while (l--) {
        var v = arr[offset];
        typeof v == 'string' ? s.push(v) : n.push(v);
        offset++;
    }
    return [s, n];
}

// 方法特性
// y_
// 前: () => [1,2,3];
// 后：(a,b,c) => ....
const y_ = 1;

function yv2(...argv) {
    var i = argv.length,
        offset = 0,
        up = 0;

    var fns = []
    while (i--) {
        var f = argv[offset];
        if (typeof f == 'function') {
            fns.push(s_or_n(argv.slice(up, offset)));
            fns.push(f);
            up = offset + 1;
        }
        offset++;
    }
    if (typeof argv[argv.length - 1] !== 'function') fns.push(s_or_n(argv.slice(up)))
    this.fns = fns;
    initEvent(this);

}


async function exec(o) {

    var fns = this.fns,
        l = fns.length,
        offset = 0;

    // 子级数据打散传入
    var one_v;
    if (arguments.length > 1) {
        o = [...arguments];
        one_v = fns[0][1][0];
        fns[0][1][0] = one_v | 1;
    };

    var is_end = {},
        focuse = {};

    while (l--) {
        var f = fns[offset];
        if (offset & 1) {
            try {
                var t = fns[offset - 1][1];
                o = t[0] && (t[0] & y_) && isArr(o) ? await f(...o) : await f(o);
                offset++;
                continue;
            } catch (err) {
                var isfocuse = Object.keys(focuse).filter(n => focuse[n])
                if (isfocuse.some(n => this.evList["err:" + n])) {
                    isfocuse.forEach(n => this.emit("err:" + n, { err, data: o, offset }));
                }
                return Promise.reject(err);
            }
        }

        f[0].forEach(n => {
            !is_end[n] ? (this.emit("s:" + n, this), focuse[n] = is_end[n] = true) : (this.emit("e:" + n, this), focuse[n] = is_end[n] = null);
        })
        offset++;

    }

    fns[0][1][0] = one_v;

    return o;
}


function expose(a, b, arr) {
    arr.forEach(n => a[n] = b[n].bind(b))
}

function yili(...argv) {
    let y = new yv2(...argv);
    let exec = async function (...argv) {
        return await y.exec(...argv)
    }

    exec.$yili = true;
    exec.y_ = y_;
    expose(exec, y, ['on', 'emit', 'self', '$yv2'])
    return exec;
}


yv2.prototype.self = function () { return this }
yv2.prototype.$yv2 = () => true;
Object.assign(yili, { y_ })
extendEvent(yv2);

yv2.prototype.exec = exec;

module.exports = yili;
module.exports.yi = yili;



